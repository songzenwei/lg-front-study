## 内容
> 通透一些
1. 面向对象（  ）
2. EventLoop( 浏览器平台 )

## 面向对象
### 名词
> 非 Class 的面向对象
> 在 JS class 只是一个语法糖（ 构造函数 ）
1. 类 、对象、实例
2. 一切皆对象，在众多的对象当中我们会发现有一些对象它们具有相同的特征
3. 此时就可以做抽象，最终产出了类
4. 实例就是我们 new 之后一个产物（对象---类---实例）
### 普通函数和构造函数
1. 不论当做哪种函数去执行，它终归是一个函数，因此堆栈执行及作用域和作用域链这套内容它是存在
2. 不同的点在于使用 new 关键字的时候会多做一些事情 
3. 当执行 new 操作的时候浏览器会自动开辟一个内存空间，用于存放实例对象。然后与 this 进行关联
4. 如果将一个函数当做构造函数那么默认会返回实例对象，如果说函数内部自己设置了返回值，且这个返回值是引用类型，那么采用自己返回的值。
### 原型及原型链 
1. 名词：prototype __proto__ Object
2. 当前我们只讨论对象（没有顾及函数也是对象这一点）
3. 实例对象是对象，所以它的身上会有一个 __proto__ 属性指向当前类的原型（ foo1身上的 __proto__ 指向 Foo.prototype)
4. 原型对象也是对象，所以它的身上也有一个 __proto__ 属性指向Object 类的原型对象
5. ( Foo.prototype.__proto__ ===》Object.prototype )

- 首先会找自己的私有属性，如果有则直接使用 
- 私有属性当中如果不存在，则默认会基于 __proto__ 属性找到它所属类的原型对象
- 如果原型对象身上也没有，则继续基于原型对象身上的 __proto__ 往上接着找，直到找到 Object.prototype 为止
### 结论
1. 堆栈作用域及作用域链（一套机制）
2. 原型及原型链（一套机制）

### 重写 new 方法
正常来说，我们遇到的原型对象， 都是一个对象
但是对于 Function来说它的 prototype 是一个匿名函数 
虽然它是一个函数，但是它的处理机制和之前的原型对象是一样的，它身上是没有 prototype 属性的
一个函数如果具备了prototype 属性有什么好处，或者说一个函数没有 prototype 属性，它又失去了什么？
不能执行 new 操作
哪些函数不具备 prototype 属性：
1. 箭头函数
2. Function.prototype 这个函数
3. 对象当中的函数简写

Object 类是一个函数，它是 new Function 来的  
Function的原型对象又是 new Object.prototype 来的  


> 自己看代码
### Function 与 Object 
1. 函数
   1. 普通函数调用（堆栈作用域及作用域链）
   2. 构造函数（ 原型及原型链 ）
   3. 对象（ 键值对 ） 【所谓的高阶应用】
   4. 上述的三种角色之间并没有必然的联系，但是函数是一等公民（ 函数就是个函数 ）
2. 语录
   1. Function 是一等公民，虽然有很多种身份，但最重要的还是函数 
   2. 每个对象都存在 __proto__ 属性，指向所属类的原型对象
   3. 每个函数存在 prototype 属性（有例外），指向它的原型对象【有的函数没有原型对象】
   4. 所有对象如果不知道谁是爹，那么就都安在 Object 身上 ，且 Object 本身也是一个函数 
   5. Function 与 Object 是JS当中二大并行的基类，虽然最终查找的落脚点都是 Object 
   6. 所有的函数都是 NEW Function 来的
   7. Function.prototype 原型对象是一个匿名函数，但是它的处理机制和其它的原型地象是一样的（指向Object.prototype）
### this 
1. this 是什么 
   1. this 就是当前函数的执行主体（谁执行了这个函数），不等同于执行上下文，也不等同于作用域
2. zce在拉勾教育讲前端（zcegg）
   1. 讲前端是一个动作（ 函数 ）
   2. 拉勾教育（ 执行上下文 ）
   3. zce就是主体， 本次函数在当前执行上下文里的 this 指向 
3. 常出现 this 的场景 
   1. 事件绑定
   2. 普通函数调用
   3. 构造函数
   4. 箭头函数（不具备this)
   5. 基于 call/bind/apply 强制改变 this 的指向 
4. 规律
   1. 函数执行的时候需要查看函数的前端是否有 . 如果有，则点前面的对象就执行主体，如果没有 . 一般就是window或undefined 
   2. 特殊情况
      1. 匿名函数中的 this 是window或者 undefined 
      2. 回调函数中的 this 是window或者 undefined 
      3. 小括号语法
   
Promise 是什么？

promise:pending fulfilled rejected
then() 得到的还是一个promise，它的状态


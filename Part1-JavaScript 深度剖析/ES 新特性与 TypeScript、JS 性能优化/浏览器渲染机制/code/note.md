## 异步编程
### 1.1 名词
> JS 是否能同时处理多件事情（同时，多进程，多线程 JS 单线程）
> JS 可以实现异步编程
> JS 事件循环是为了解决什么问题 ( EventLoop EventQueue 机制 、阻塞 )
> JS 事件循环，循环如何体现的
> 不局限于知道代码题的运行结果
- 进程：一个应用程序（例如浏览器，打开了一个界面）
- 线程：线程就是进程当中具体做事情的人
- 一个进程当中可以包含多个线程 
- 同步编程：一件事情做完之后才能去做另外一件事情（ 单线程 ）
- 异步编程：上一件事情没有处理完的情况下，就可以去做下一件事情（ 多线程 ）
- JS 代码在浏览器中执行，而浏览器是多进程的，当我们打开一个界面的时候就相当于开启了一个进程，在这一个进程里会存在多个线程（JS引擎、GUI渲染、HTTP网络请求、DOM事件监听器、定时器监听线程.....), 其中 JS引擎就来执行 JS 代码，很明显它是一个单线程，因为它是单线程所以默认情况下它只能同步的完成代码执行，但是我们发现 JS 里也可以实现异步，这是因为它内部存在事件循环和事件队列机制。
- JS 常见异步行为
  - ajax 
  - 事件绑定
  - promise （ then ）
  - 定时器 
  - async await generator
- JS 事件循环模型图
- 执行顺序 
  - 整体顺序
    - 同步任务
    - 微任务
    - 宏任务
  - 异步任务执行顺序
    - 先执行微任务（  ）【如果微任务队列中存在二个微任务，那么先执行哪一个】
      - 先放的先执行（99%都是对）
      - 微任务是否一定先于宏任务执行（ 1 2 ）【如果你认为微任务一定先于宏任务执行，那么今晚好好听】
    - 宏任务（如果有多个宏任务，谁先执行）
  - 总结：不论是微还是宏，统一定一下，哪个先到执行时机，谁就先执行 （执行时机，从代码中找感觉）
- 定时器
  - setTimeout(function foo1(){}, 1000)
    - 一种就是1s钟之后才放入队列
    - 一种setTimeout 是同步操作，立即放入队列（今晚）
  - 定时器执行之后返回一个数值，表示当前系统内的第几个定时器 
  - 将等待时间设置为 0 ，它也不是立即就执行
    - 定时器做动画是不靠谱的，因为有些时候设置的等待时间已经到了，但是异步操作还没有到执行的时机（微任务）
    - 每个浏览器都存在一个最小的反应时间（ 4~6ms ）
  
Promise( 你们都懂 )
1. executor 函数
   1. 我们在执行 new Promise 操作的时候必须传入一个参数，且这个参数只能是函数, 这个函数我们称之为 executor 函数
   2. executor 函数能接收二个函数做为参数， 且 executor 函数是立即执行了
   3. executor 里虽然能写同步的代码但是，我们一般用它来管理异步代码
2. Promise实例
   1. new 操作执行之后肯定会返回一个值，这个值就是 Promise 实例 
   2. [[PromiseState]]: Promise 状态， pending   fulfilled  rejected
   3. [[PromiseResult]]: Promise 值， undefined  成功的值    失败的原因 
   4. __proto__ 属性可以找到原型对象，身上有 then catch finally 
3. 状态切换
   1. 执行 resolve 的时候将实例状态改变为成功态，此时值就是当前 resolve 调用时接收的值 
   2. 执行 reject 的时候将实例状态改变失败态，此时的值就是..... 
   3. 如果executor 函数执行报错，则状态也会切换至失败态，此时promise 的值就是当前报错的原因
   4. promise 的状态一旦切换了，就不会再改变（ ）
4. 状态和值 
   1. new Promise 获取实例
      1. 调用 resolve reject 
      2. executor 函数执行中是否存在报错
   2. 调用 then 方法返回实例
      1. then 注入的两个主法不论哪个执行，只要执行不报错， 则新实例的状态就是 fulfilled ， 反之就是 rejected ，值就是返回值
      2. 手动返回一个 promise ，此时新 promise 的值和状态取决当前返回的 promise 

1. async 特点
   1. async 用于修饰函数，默认让返回返回一个成功的 promise 实例
   2. 如果函数执行报错，则promise 状态为 rejected ，值就是报错原因 
   3. 如果函数执行正常则实例对象的状态为 fulfilled， 值为函数的返回值，如果没有return 则 undefined 
2. await 语法
   1. await 后面放置一般都是 promise 实例，如果不是，它会给你处理成 Promise.resolve() 
   2. await foo(), 此语法就相当于是立即执行 foo函数， 接收到 foo 函数的返回值之后处理为 Promise
   3. 假如说 await foo() 后面还有代码，它就会将后面的代码整体看做是一个异步的微任务，等到它前面的 promise 状态明确之后再按规则执行。

ret1 = await foo()
ret2 = await foo()
console.log(111)



